补码的设计使得有符号数和无符号数的运算过程是一样一样的。

比方说(1000 0001)B，无论是当成有符号的-127还是无符号的129，执行
add al,1
后结果都是(1000 0010)B，这个数可以看成是有符号的-126，也可以看成是无符号的130，计算结果跟数学上的-127+1=-126或者129+1=130是一致的。
补码的设计使CPU运算时压根不用考虑数据是不是有符号，但为了方便程序员，CPU计算完成后会根据结果 同时 设置N个符号位，如SF、ZF、CF、OF、PF等，根据各标志位就可以同时知道有符号数和无符号数的计算结果。

注意“同时”两字。

CF主要是针对无符号数：
计算结果超出寄存器可存储的宽度了就把CF置为1，如al=(1111 1111)B, 数学上来说，(al)+1=(1 0000 0000)B，但al只能存8位，即(al)=(0000 0000)B，进位的1怎么办？CF=1。

OF主要针对有符号数：
当把操作数作为有符号数解释时，如果计算结果出错了就把OF置为1。
如(al)=(0000 0010)B，(bl)=(0111 1111)B，add al,bl，(al)=(1000 0001)B。在数学上，两个正数相加结果还是正数，但按有符号数解释的话(1000 0001)B是负数，计算结果“出错”了，CPU就将OF置1。
------------------------over--------------------------
附：
上面说了，CPU会根据结果同时设置N个符号位：
(1111 1111)B+1=(1 0000 0000)B   会置ZF=1，OF=0，CF=1，SF=0；
(0000 0010)B+(0111 1111)B=(1000 0001)B   会置ZF=0，OF=1，CF=0，SF=1，你可以算算为什么会这样。
